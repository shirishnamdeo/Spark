Spark Structured Streaming

Structured Streaming is a scalable and fault-tolerant stream processing engine built on the Spark SQL engine. [Why on SQL engine??]
You can express your streaming computation the same way you would express a batch computation on static data.
The Spark SQL engine will take care of running it incrementally and continuously and updating the final result as streaming data continues to arrive.

You can use the Dataset/DataFrame API in Scala, Java, Python or R to express streaming aggregations, event-time windows, stream-to-batch joins, etc.
** Q. Does RDD's supported?

The computation is executed on the same optimized Spark SQL engine.
Finally, the system ensures end-to-end exactly-once fault-tolerance guarantees through checkpointing and Write-Ahead Logs.

Structured Streaming provides fast, scalable, fault-tolerant, end-to-end exactly-once stream processing without the user having to reason about streaming.


Internally -> Micro Bacthes (Data Stream as micro-batch jobs, with latency as low as 100 mili-seconds)

However, since Spark 2.3, we have introduced a new low-latency processing mode called Continuous Processing, which can achieve end-to-end latencies as low as 1 millisecond with at-least-once guarantees.


2 Model of Streaming:
	Micro Batch Processing Model (Default)
	Continuous Processing Model




Apache Spark 2.0 laid the foundational steps for a new higher-level API, Structured Streaming, for building continuous applications. 
[A streaming model that supports end-to-end applications that continuously react to data in real-time, We call them continuous applications that react to data in real-time.]
Apache Spark 2.1 extended support for data sources and data sinks, and buttressed streaming operations, including event-time processing watermarking, and checkpointing


Central to Structured Streaming is the notion that you treat a stream of data not as a stream but as an unbounded table. As new data arrives from the stream, new rows of DataFrames are appended to an unbounded table.

DStream (Discretized Stream) is the basic abstraction of Spark Streaming.




-----------------------------------------------------------------------------------------------------------------------------------------------------

Streaming Programming Model:

The key idea in Structured Streaming is to treat a live data stream as a table that is being continuously appended.
This leads to a new stream processing model that is very similar to a batch processing model. 
You will express your streaming computation as standard batch-like query AS ON A static table, and Spark runs it as an incremental query on the UNBOUNDED input table.
-- That is the input stream data can bee seen as it is appending to a input unbounded table, and we can write similar query as we would have written for a static table.

-> Data Stream as a Unbound Table

A query on the input will generate the “Result Table”. Every trigger interval (say, every 1 second), new rows get appended to the Input Table, which eventually updates the Result Table. 
Whenever the result table gets updated, we would want to write the changed result rows to an external sink.


The 'Output' is defined as what gets written out to the external storage. The output can be defined in a different mode:
	Complete Mode:
		The entire updated Result Table will be written to the external storage. 
		It is up to the storage connector to decide how to handle writing of the entire table.

	Append Mode:
		Only the new rows appended in the Result Table since the last trigger will be written to the external storage. 
		This is applicable only on the queries where existing rows in the Result Table are not expected to change.

	Update Mode:
		Only the rows that were updated in the Result Table since the last trigger will be written to the external storage (available since Spark 2.1.1). 
		Note that this is different from the Complete Mode in that this mode only outputs the rows that have changed since the last trigger. 
		If the query doesn’t contain aggregations, it will be equivalent to Append mode.



Note that Structured Streaming does not materialize the entire table. 
It reads the latest available data from the streaming data source, processes it incrementally to update the result, and then discards the source data. 
It only keeps around the minimal intermediate state data as required to update the result (e.g. intermediate counts in the earlier example).

This model is significantly different from many other stream processing engines. 
Many streaming systems require the user to maintain running aggregations themselves, thus having to reason about fault-tolerance, and data consistency (at-least-once, or at-most-once, or exactly-once). 
In this model, Spark is responsible for updating the Result Table when there is new data, thus relieving the users from reasoning about it.




-> Handling Event-time and Late Data (Water Marking - to allow users to specify the threshold on the late data)

-> Fault Tolerance Semantics (to delivering end to end exactly once semantic):
	-- Structured Streaming sources, the sinks and the execution engine to reliably track the exact progress of the processing so that it can handle any kind of failure by restarting and/or reprocessing.
	-- Every streaming source is assumed to have offsets (similar to Kafka offsets, or Kinesis sequence numbers) to track the read position in the stream.
	-- The engine uses checkpointing and write-ahead logs to record the offset range of the data being processed in each trigger.
	-- The streaming sinks are designed to be idempotent for handling reprocessing.




-----------------------------------------------------------------------------------------------------------------------------------------------------

API using DataFrame / DataSets

Spark 2.0 DataFrame and DataSets can represents static, bounded data, as well as streaming, unbounded data (Streaming DataFrame / DataSets).

Streaming DataFrames can be created through the DataStreamReader interface (Scala/Java/Python docs) returned by SparkSession.readStream()

Input Soruce:
	File Source (CSV, TXT, JSON, PARQUET, ORC)
	Kafka Source
	Socket Source
	Rate Source (for testing and benchmarking)



// Read text from socket
val socketDF = spark
  .readStream
  .format("socket")
  .option("host", "localhost")
  .option("port", 9999)
  .load()


socketDF.isStreaming    // Returns True for DataFrames that have streaming sources
socketDF.printSchema



// Read all the csv files written atomically in a directory
val userSchema = new StructType().add("name", "string").add("age", "integer")
val csvDF = spark
  .readStream
  .option("sep", ";")
  .schema(userSchema)            -- Specify schema of the csv files
  .csv("/path/to/directory")     -- Equivalent to format("csv").load("/path/to/directory")


These examples generate streaming DataFrames that are untyped, meaning that the schema of the DataFrame is not checked at compile time, only checked at runtime when the query is submitted. 
** Some operations like map, flatMap, etc. need the type to be known at compile time. 
To do those, you can convert these untyped streaming DataFrames to typed streaming Datasets using the same methods as static DataFrame.




--> Schema inference and partition of streaming DataFrames/Datasets
[https://spark.apache.org/docs/latest/structured-streaming-programming-guide.html#schema-inference-and-partition-of-streaming-dataframesdatasets]





Operations on streaming DataFrames/Datasets:
[https://spark.apache.org/docs/latest/structured-streaming-programming-guide.html#operations-on-streaming-dataframesdatasets]

You can apply all kinds of operations on streaming DataFrames/Datasets – ranging from untyped, SQL-like operations (e.g. select, where, groupBy), to typed RDD-like operations (e.g. map, filter, flatMap).


Example:

case class DeviceData(device: String, deviceType: String, signal: Double, time: DateTime)
val df: DataFrame = ...                            -- streaming DataFrame with IOT device data with schema { device: string, deviceType: string, signal: double, time: string }
val ds: Dataset[DeviceData] = df.as[DeviceData]    -- streaming Dataset with IOT device data

-- Select the devices which have signal more than 10
df.select("device").where("signal > 10")      -- using untyped APIs   
ds.filter(_.signal > 10).map(_.device)        -- using typed APIs

-- Running count of the number of updates for each device type, using untyped API
df.groupBy("deviceType").count()

-- Running average signal for each device type
import org.apache.spark.sql.expressions.scalalang.typed, using typed API
ds.groupByKey(_.deviceType).agg(typed.avg(_.signal))


-- Register the DataFrame/Dataset as temporaty view
df.createOrReplaceTempView("updates")
spark.sql("select count(*) from updates")  


